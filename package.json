{
    "author": {
        "name": "Golyshev Dmitrii",
        "email": "golyshev.dmitry@yandex.ru"
    },
    "bugs": {
        "url": "https://github.com/fistlabs/fist.app/issues"
    },
    "contributors": [
        {
            "name": "Golyshev Dmitrii",
            "email": "golyshev.dmitry@yandex.ru"
        }
    ],
    "dependencies": {
        "fist.lang.foreach": "0.0.x",
        "fist.lang.toarray": "0.0.x",
        "fist.util.component": "0.0.x",
        "fist.io.server": "0.1.x",
        "fist.util.task": "0.0.x"
    },
    "description": "fist application",
    "devDependencies": {
        "jscs": "",
        "eslint": "",
        "nodeunit": "",
        "istanbul": "",
        "asker": ""
    },
    "license": "MIT",
    "main": "Fist",
    "name": "fist.app",
    "repository": {
        "type": "git",
        "url": "git://github.com/fistlabs/fist.app.git"
    },
    "scripts": {
        "test": "tools/test"
    },
    "version": "0.0.3",
    "readme": "fist.app [![Build Status](https://travis-ci.org/fistlabs/fist.app.png?branch=v0.0.x)](https://travis-ci.org/fistlabs/fist.app)\n=========\n\nManual usage (not recommended)\n---------\n\n```js\nvar Fist = require('fist.app/Fist');\nvar fist = new Fist();\n\n//  actions declaration\nfist.decl('users', function (track, result, done) {\n  done(null, ['pete', 'abraham']);\n});\n\nfist.decl('index', ['users'], function (track, result) {\n\n  var users = result.users.map(function (name) {\n      return '<li>' + name + '</li>';\n  }).join('');\n  track.header('Content-Type', 'text/html');\n  track.send(200, '<ul>' + users + '</ul>');\n});\n\n//  binding routes to actions\nfist.route('GET', '/', 'index');\n\n//  listen to port\nfist.listen(1337);\n\n```\nRecommended way\n---------\n\nДля удобной организации кода приложения имеет смысл создать как минимум 2 директории для датапровайдеров, в одной будут храниться \"чистые\" датапровайдеры, которые не будут писать во ```view```, в другой те, в которых непостредственно происходит шаблонизация данных и отправка на клиент. В случае выше чистым датапровайдером является ```users```, а ```index``` - производит шаблонизацию данных и отправку изх на клиент.\nПусть эти директории будут названы ```data``` и ```view``` например. Формат у этих датапровайдеров абсолютно одинаковый, но имеет смысл не смешивать их в одной директории просто по эстетическим соображениям.\nКаждый файл в директории будет являться декларацией датапровайдера. Декларация имеет простейший интерфейс, который нужно имплементировать. Это массив строк deps (или просто строка если одна зависимость) и data - любое значение, если будет функция, то будет вызвана. Пример датапровайдера ```users``` из примера выше:\n\n```js\n//  users.js\n//  Это можно совсем не писать если нет зависимостей\nexports.deps = [];\nexports.data = function (track, result, done) {\n    // это резолвинг датапровайдера с положительным результатом\n    //  done('ERR') - реджект\n    done(null, ['pete', 'abraham']);\n};\n```\n\nВ данном примере датапровайдер возвращает всегда статический результат, можно было бы просто написать\n```js\nexports.data = ['pete', 'abraham'];\n```\n\nУ датапровайдеров есть несколько фишек и особенностей. Во первых имена файлов. Имя файла является ключом под которым результат резолвинга будет помещен в ```result``` или в ```errors``` соответственно. Но есть одно \"но\".\nЭто имя всегда приводится к camelCase по таким правилам:\n\n * users -> users\n * Users -> users\n * USERS -> users\n * ABBRUsers -> abbrUsers\n\nИ указывая зависимости необходимо это учитывать.\n\nЕще одной особенностью являются точки в именах файлов. Расширение .js всегда отсекается, но другое отсечаено не будет и имена вроде ```users.names.js``` будут интерпретированы как path и результатом будет объект с ссответствующей вложенностью.\n\nИ наконец еще одной особенностью явзяется то, что если файл датапровайдера экспортирует функцию, то она юужет воспринята как конструктор и проинстанцирована с объектом параметров который был передан в ```new Fist(params)```\n\nПри инстанцировании Fist надо указать параметр action который является строкой или массивом строк-директорий кде у вас лежат датапровайдеры.\n```js\nvar fist = new Fist({\n    action: [\n        Path.resolve('data'),\n        Path.resolve('view');\n    ]\n})\n```\n\nFist не занимается резолвингом путей до директорий, поэжтому необхъодимо об этом позаботиться самостоятельно, если не хотите чтобы в разных окружениях были приблемы с путями, например если http-сокет будет лежать в другой директории при деплое в продакшн.\n\nЕсли передать параметр action, то директории считаются и провайдеры автоматически продекларируются. Останется только разобраться с маршрутами.\n\nКаждый маршрут это метод запроса, pattern в терминах fist.router и имя датапровайдера к которому будет привязан этот маршрут.\n\nЧтобы руками не декларировать каждый из маршрутов, напишите такой конфиг router.json:\n\n```json\n[\n    {\n        \"name\": \"index\",\n        \"expr\": \"/\",\n        \"verb\": \"GET\"\n    }\n]\n```\n\nи передайте его в конструктор Fist:\n\n```js\nvar fist = new Fist({\n    action: [],\n    routes: require('router.json')\n});\n\nfist.listen(1337);\n```\n"
}
